<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Epistemic Logic Playground</title>
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,700">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/app.css">
    <link rel="stylesheet" href="css/ours.css">
    <link rel="stylesheet" href="js/libs/jsoneditor-4/dist/jsoneditor.min.css">
    <script data-main="js/config" src="js/libs/require.js"></script>
</head>

<body>
    <div class="container" id="playground">
        <header class="row">
            <div class="col-md-12">
                <h1>
                    Epistemic Logic Playground
                </h1>
            </div>
        </header>
<!--         <section class="row" id="app">
            <div class="col-md-3" id="app-info">
                <div class="row" id="editor_container">
                    <div class="col-md-12" id="json_editor"></div>
                </div>
                <div class="row">
                    <div class="col-md-12">
                        <button type="button" id="json_submit_button">Submit</button>
                    </div>
                </div>
            </div>
            <div class="col-md-9" id="app-canvas">
            </div>
        </section> -->
        <section id="response">
        </section>
        <section class="row" id="report">
            <h2>Introduction</h2>
                <p>
                    This page presents our project for the course Multi-Agent systems, we have build a system that given some model $\model$, some formula, and some state determines if the formula is true in that state. The following logics are supported:
                    <ul class="quad">
                        <li>$\K{\m}$</li>
                        <li>$\T{\m}$</li>
                        <li>$\SV{\m}$</li>
                        <li>$\SF{\m}$</li>

                        <li>$\KEC{\m}$</li>
                        <li>$\TEC{\m}$</li>
                        <li>$\SVEC{\m}$</li>
                        <li>$\SFEC{\m}$</li>                    

                        <li>$\KI{\m}$</li>
                        <li>$\TI{\m}$</li>
                        <li>$\SVI{\m}$</li>
                        <li>$\SFI{\m}$</li>                                        
                    </ul>
                    We refer the reader to <cite>Epistemic Logic for AI and Computer Science by J.-J Ch. Meyer and W. van der Hoek</cite> for an explanation of the different logics.</p>

                <p>
                    The modelchecker, consists of a back-end written in <a href="https://www.python.org">Python</a> and a front-end that visualizes the model using <a href="http://d3js.org">D3</a>. One advantage of this approach is that it split the model cleanly in two independent halves. Another is that javascript is much more suitable for the visualisation and interaction than Python. Since Javascript does not support polymorphism we felt that Pyton was the better choice for the back-end.
                </p>

                <p>
                    Below we discuss the <a href="#implementation">implementation</a> of the modelchecker and the <a href="#visualisation">visualisation</a> of the model. 
                </p>
            <h2><a name="implementation">Implementation</a></h2>
                <p>
                    In this section we discuss the used representation of the <a href="#formula">formulas</a>, the models <a href="#model">models</a> and, how we determine if some formula holds in some state in some model, i.e. how the <a href="#checker">checker</a> works.
                </p>
                <h3><a name="formula">Formula</a></h3>
                    <p>
                        Users of the 'Epistemic Logic Playground' input formulas as strings, for example the formula 
                            \begin{equation} 
                                \label{eq:exampleFormula} 
                                C K_1 \lnot (a \land b), 
                            \end{equation}
                        is input as <code>C K_1 ~(a &amp; b)</code>. The table below presents the representation users should use to represent a formula. Furthermore for each operator the logics in which it is supported is presented in the table. 
                    </p>

                    <p>
                        Readers familiar with <a href="https://github.com/gertvv/oops">OOPS</a> might recognise some of the notation we use. However since we do not use the exact same notation as OOPS the OOPS operators are also provided in the table below to avoid confusion.
                    <p/>

                    <table class="table table-striped table-hover table-condensed">
                        <tr>
                            <th width="160"></th>
                            <th>Conventional notation</th>
                            <th width="80em">Input format</th>
                            <th width="250">Logics</th>
                            <th>OOPS notation</th>                                
                            <th>Notes</th>
                        </tr>
                        <tr>
                            <td>Proposition</td>
                            <td>$A$</td>
                            <td><code>a</code></td>
                            <td>all supported logics</td>
                            <td><code>a</code></td>
                            <td>
                                The name of a proposition must start with a small letter.
                            </td>
                        </tr>
                        <tr>
                            <td>Negation</td>
                            <td>$\lnot A$</td>
                            <td><code>~a</code></td>
                            <td>all supported logics</td>     
                            <td><code>~a</code></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Conjunction</td>
                            <td>$A \land B$</td>
                            <td><code>a &amp; b</code></td>
                            <td>all supported logics</td> 
                            <td><code>a &amp; b</code></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Disjunction</td>
                            <td>$A \lor B$</td>
                            <td><code>a | b</code></td>
                            <td>all supported logics</td> 
                            <td><code>a | b</code></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Implication</td>
                            <td>$A \to B$</td>
                            <td><code>a -&gt; b</code></td>
                            <td>all supported logics</td> 
                            <td><code>a &gt; b</code></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Equivalence</td>
                            <td>$A \leftrightarrow B$</td>
                            <td><code>a &lt;-&gt; b</code></td>
                            <td>all supported logics</td> 
                            <td><code>a = b</code></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Knowledge</td>
                            <td>$K_i$</td>
                            <td><code>K_i</code></td>
                            <td>all supported logics</td> 
                            <td><code>#_i</code></td>                                
                            <td>
                                The name of the agent must be a number.
                            </td>
                        </tr>
                        <tr>
                            <td>Possible</td>
                            <td>$M_i$</td>
                            <td><code>M_i</code></td>
                            <td>all supported logics</td> 
                            <td><code>%_i</code></td>                                                      
                            <td>The name of the agent must be a number.</td>
                        </tr>
                        <tr>
                            <td>Common knowledge</td>
                            <td>$C$</td>
                            <td><code>C</code></td>
                            <td>$\KEC{\m}$, $\TEC{\m}$, $\SVEC{\m}$, $\SFEC{\m}$</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Everybody</td>
                            <td>$E$</td>
                            <td><code>E</code></td>
                            <td>$\KEC{\m}$, $\TEC{\m}$, $\SVEC{\m}$, $\SFEC{\m}$</td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>Intention</td>
                            <td>$I$</td>
                            <td><code>I</code></td>
                            <td>$\KI{\m}$, $\TI{\m}$, $\SVI{\m}$, $\SFI{\m}$</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>

                    <p>
                        Given some formula we need a suitable representation to determine if it holds in some model in some state. We represent formulas as an <a href="#expressiontree">expression tree</a>. Before parsing the formula, to generate the expression tree we first convert it to list of <a href="#tokens">tokens</a>.
                    </p>

                    <h4><a name="tokens">Tokens</a></h4>
                        <p>
                            Formulas that enter the model checker are converted to a list of tokens. The tokenized version of \eqref{eq:exampleFormula} is shown in the figure below. 
                        </p>

                        <figure>
                            <object data="./img/tokenization.svg" type="image/svg+xml" align="middle">
                                <img src="./img/tokenization.png" />
                            </object>
                            <figcaption>
                                Tokenization of formula \eqref{eq:exampleFormula}.
                            </figcaption>
                        </figure>

                        <p>
                        The advantage of tokenizing is that it is easier to change the definition of the non terminals of the grammar without having to change the parser itself. Another upside of representing the formula as a list of tokens before parsing it is that we can already detect some errors in the formulas. For example if a user has selected the axiom system $\SF{\m}$ and inputs formula \eqref{eq:exampleFormula} the process that generates the list of tokens detects that the formula is well formed in that language, since the operator $C$ is not defined in $\SF{\m}$. Consequently, if we present a list of tokens to the parser we do not need to consider cases where a formula contained tokens that are not allowed. 
                        </p>
                    <figure class="float-right">
                        <object data="./img/ast.svg" type="image/svg+xml">
                            <img src="./img/ast.png" />
                        </object>
                        <figcaption>
                            Expression tree of formula \eqref{eq:exampleFormula}.
                        </figcaption>
                    </figure>

                    <h4><a name="expressiontree">Expression Tree</a></h4>
                    <p>
                        Given a list of tokens we need to build an expression tree. We do this according to the following grammar: 

                        \begin{array}{cccl}
                        \mathbf{X} & := & ~ & 
                            \mathbf{T} \land \mathbf{T}               \; | \; 
                            \mathbf{T} \lor \mathbf{T}                \; | \; 
                            \mathbf{T} \to \mathbf{T}                 \; | \; 
                            \mathbf{T} \leftrightarrow \mathbf{T}     \\ 
                        \mathbf{T} & := & ~ & 
                            \text{I}\: \mathbf{F}     \; | \; 
                            \text{E}\: \mathbf{F}     \; | \;                             
                            \text{C}\: \mathbf{F}     \; | \; 
                            \text{K}_i\: \mathbf{F}   \; | \; 
                            \text{M}_i\: \mathbf{F}   \\ 
                        \mathbf{F} & := & ~ & 
                            \left( \mathbf{X} \right)    \; | \; 
                            ~ \lnot \mathbf{X}           \; | \; 
                            \mathit{proposition}                \\ 
                        \end{array} 

                        Terminals, parts of the expression that cannot be expanded according to some rule in the grammar, are presented as their symbol ($\lnot$, $\land$, $\lor$, $\to$, $($, $)$, $\leftrightarrow$) or as <em>italic text</em>. Non-terminals, parts of the grammar that can be expanded according to some rule, are shown in <b>bold</b>. 
                    </p>
        
                    <p>
                        The presented grammar is LL(1), which means that it can be parsed using a predictive recursive descent parser. A consequence of using such a parser is that the binary operators in the grammar are interpreted as right-associative, i.e. the expression $a \land b \land c$ is parsed as $(a \land (b \land c))$.                        
                    </p>

                    <p>
                        The parser generates an expression tree representing the formula if we give a list of tokens. The tree generated for \eqref{eq:exampleFormula} is presented on the right. The structure of the tree represents the order in which parts of the formula should be evaluated. For example, $a \land b$ should be evaluated first, and the result of that expression should be negated. If we had not placed brackets around the conjunction, the negation node would have been a child of the conjunction node, which represents the expression $(\lnot a) \land b$.
                    </p>

                    <p>
                        Any errors in the formula that have not been detected during tokenization are detected during parsing. For example if we input the formula $a \land \land b$ the parser generates an error, since it expects to find the non-terminal $\mathbf{T}$ after $\land$ but finds the terminal $\land$.
                    </p>                    
                <h3><a name="model">Model</a></h3>
                    <p>
                        The front-end sends a JSON-representation of the Kripke model to the back-end which generates its own representation of the model. A model is represented as a list of <span class="tt">states</span>. For each agent a <span class="tt">state</span> has a list of incoming and outgoing <span class="tt">relations</span>. Furthermore a state has a valuation for each proposition in the model. Each <span class="tt">relation</span> has an <span class="tt">agent</span>, and a source and destination <span class="tt">state</span>.
                    </p>
                    <p>
                        When converting the JSON representation to our own representation we check the model for inconsistencies. We check for example that the model has at least one state, or that it all relations in the model are between defined states.
                    </p>
                    <p>
                        The Epistemic Logic Playground supports four classes of Kripke models, namely:
                            <ul>
                                <li>$\mathcal{K}$: the class of all Kripke models without specific properties.</li>
                                <li>$\mathcal{T}$: the class of all reflexive Kripke models.</li>
                                <li>$\mathcal{S4}$: the class of all reflexive-transitive Kripke models.</li>
                                <li>$\mathcal{S5}$: the class of all reflexive-transitive-symmetric Kripke models.</li>
                            </ul>
                        The user does not need to specify which class his model has explicitly, since this follows from the selected logic. If the logic $\T{}$, $\TEC{}$ or $\TI{}$ is selected the associated class of Kripke models, $\mathcal{T}$ is selected automatically. 
                    </p>
                    <p>
                        If the class $\mathcal{T}$ is selected, not only is the input model converted from JSON, the reflexive closure of the relations is also computed using. In the case that a logic associated with the class $\mathcal{S4}$ is selected the reflexive-transitive closure of the set of relations of the models is computed using depth first search. In the same way the reflexive-transitive-symmetric closure of the relations is computed if the selected logic is one of $\SF{}$, $\SFEC{}$, $\SFI{}$. The updated model is returned to the front-end and visualised there. Consequently one does not need to input a reflexive-transitive model to evaluate a formula in e.g. $\SVEC{}$.
                    </p>

                <h3><a name="checker">Checker</a></h3>

                    <h4>True or False?</h4>
                        <p>
                            Given some model, state and formula we need to determine if that formula holds or does not hold. This process starts at the root of the expression tree, the <span class="tt">Common</span> node in the presented expression tree. We then determine in which state(s) the child of this node, the subtree with <span class="tt">Knowledge</span> should hold. This recursive process halts if we arrive at a <span>Proposition</span> node, in which case the valuation of that proposition in the current state is requested from the model. 
                        </p>

                        <p>
                            Each node is evaluated lazily, for example if the left handed side of a disjunction is evaluated as true we do not evaluate the right handed side, since it does not matter if that disjunct is true or false.
                        </p>

                        <p>
                            Although most types of nodes have a truth condition, i.e. the <span class="tt">Negation</span> node 'knows' that it is true if its child is not true, some are evaluated differently. These nodes are 'rewritten' before evaluation, e.g. the <span class="tt">implication</span> node is transformed to a disjunction of implication nodes, see the image below. 

                            <figure>
                                <object data="./img/transformations.svg" type="image/svg+xml">
                                    <img src="./img/transformations.png" />
                                </object>
                                <figcaption>
                                    An expression tree representing an implication is transformed.
                                </figcaption>
                            </figure>                            

                            The equivalence relation and the operator $\text{M}_i$ are evaluated are also evaluated by transforming the expression tree.
                        </p>

                    <h4>Motivation</h4>
                        <p>Explaini how the motivation tree is generated and give an example given some model and the formula above.</p>


            <h2><a name="visualisation">Visualisation</a></h2>
                <p>
                    The visualisation depicts a Kripke model as a graph. The worlds have a label that shows the valuations of the atomic propositions at that world. Reflexive relations are not supported at this moment.
                </p>
                <h3>How To Use</h3>
                <p>
                    At this stage the user interface is not quite finished yet and a (probably) temporal solution is in place. This temporal solution includes an json editor in which the model can be edited. Our goal is to include a more user friendly interface where states and links can be added by simply clicking in the in the graph canvas.
                </p>
                <h4>JSON Format</h4>
                <p>
                    An example is included in the editor for this. It contains an object called model. Within this model the states, relations, and logic system are defined.
                    <ul>
                        <li> <strong>States</strong> is an array of objects. Each object represents a state and needs to have an "id" field followed by an integer. This id is used later in the relations. The "vals" field is followed by an array of valuations. The order of these valuations needs to be the same as that of the propositions array
                        </li>
                        <li> <strong>Relations</strong> This object needs to be an array of arrays. The inner arrays describe a relation between two states and of which of the maximum 5 agents this relations belongs to.
                        </li>
                        <li>
                            <strong>
                        Logic System
                    </strong> The logic system the Kripke belongs to. Will in final version compute the reflexive transitive etc. closures when that is necessary. Options for the logic system are "KM", "S5", and "S5CE"
                        </li>
                    </ul>
                    The model object is followed by the formula you want to check on the system. Syntax is described in the table at the top of the page. The state field tells the model checker in which state the formula should hold.
                </p>

        </section>
    </div>
    <footer class="footer">
        <div class="container">
            <p class="text-muted">
                Epistemic Logic Playground is an adaption of
                <a href="https://github.com/rkirsling/modallogic">Modal Logic Playground</a> by
                <a href="https://bitbucket.org/rick_van_veen">Rick van Veen</a> and
                <a href="https://github.com/lauraBaakman">Laura Baakman</a>, released under the
                <a href="http://opensource.org/licenses/mit-license.php"> 
            MIT License</a>.
            </p>
        </div>
    </footer>
</body>

</html>
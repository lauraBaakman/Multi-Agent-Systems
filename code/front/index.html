<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Epistemic Logic Playground</title>
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300,400,700">
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/app.css">
    <link rel="stylesheet" href="css/ours.css">
    <link rel="stylesheet" href="js/libs/jsoneditor-4/dist/jsoneditor.min.css">
    <script data-main="js/config" src="js/libs/require.js"></script>
</head>

<body>
    <div class="container">
        <header class="row">
            <div class="col-md-12">
                <h1>
                    Epistemic Logic Playground
                </h1>
            </div>
        </header>
        <section id="app">
            <div id="mode-select" class="btn-group">
                <button class="btn btn-primary active" onclick="app.setAppMode(app.MODE.EDIT)">
                    <i class="icon-pencil icon-white"></i> Edit Model
                </button>
                <button class="btn btn-primary" onclick="app.setAppMode(app.MODE.EVAL)">
                    <i class="icon-eye-open icon-white"></i> Evaluate Formula
                </button>
            </div>
            <div id="model-link">
                <button class="btn btn-inverse" onclick="app.showLinkDialog()">Link to Current Model</button>
            </div>
            <div id="app-body">
                <div class="panel tab-content">
                    <div id="edit-pane" class="tab-pane active">
                        <div class="var-count">
                            Number of propositional variables:
                            <div class="btn-group">
                                <button class="btn" onclick="app.setVarCount(1)">1</button>
                                <button class="btn active" onclick="app.setVarCount(2)">2</button>
                                <button class="btn" onclick="app.setVarCount(3)">3</button>
                                <button class="btn" onclick="app.setVarCount(4)">4</button>
                                <button class="btn" onclick="app.setVarCount(5)">5</button>
                            </div>
                        </div>
                        <div class="alert alert-info">
                            <div class="selected-node-id">No state selected</div>
                            <table class="propvars inactive">
                                <tbody>
                                    <tr class="">
                                        <td class="var-name">p:</td>
                                        <td class="var-value">
                                            <div class="btn-group">
                                                <button class="btn btn-small btn-success" onclick="app.setVarForSelectedNode(0,true)">True</button>
                                                <button class="btn btn-small btn-danger" onclick="app.setVarForSelectedNode(0,false)">False</button>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr class="">
                                        <td class="var-name">q:</td>
                                        <td class="var-value">
                                            <div class="btn-group">
                                                <button class="btn btn-small btn-success" onclick="app.setVarForSelectedNode(1,true)">True</button>
                                                <button class="btn btn-small btn-danger" onclick="app.setVarForSelectedNode(1,false)">False</button>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr class="inactive">
                                        <td class="var-name">r:</td>
                                        <td class="var-value">
                                            <div class="btn-group">
                                                <button class="btn btn-small btn-success" onclick="app.setVarForSelectedNode(2,true)">True</button>
                                                <button class="btn btn-small btn-danger" onclick="app.setVarForSelectedNode(2,false)">False</button>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr class="inactive">
                                        <td class="var-name">s:</td>
                                        <td class="var-value">
                                            <div class="btn-group">
                                                <button class="btn btn-small btn-success" onclick="app.setVarForSelectedNode(3,true)">True</button>
                                                <button class="btn btn-small btn-danger" onclick="app.setVarForSelectedNode(3,false)">False</button>
                                            </div>
                                        </td>
                                    </tr>
                                    <tr class="inactive">
                                        <td class="var-name">t:</td>
                                        <td class="var-value">
                                            <div class="btn-group">
                                                <button class="btn btn-small btn-success" onclick="app.setVarForSelectedNode(4,true)">True</button>
                                                <button class="btn btn-small btn-danger" onclick="app.setVarForSelectedNode(4,false)">False</button>
                                            </div>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="instructions">
                            <ul class="unstyled">
                                <li>Click in the open space to <strong>add a state</strong></li>
                                <li>Drag between states to <strong>add a transition</strong></li>
                                <li>Ctrl-drag a state to <strong>move</strong> graph layout</li>
                                <li>Click a state or a transition to <strong>select</strong> it</li>
                                <li>
                                    When a state is selected:
                                    <ul>
                                        <li><strong>R</strong> toggles reflexivity</li>
                                        <li><strong>Delete</strong> removes the state</li>
                                    </ul>
                                </li>
                                <li>
                                    When a transition is selected:
                                    <ul>
                                        <li><strong>L</strong>(eft), <strong>R</strong>(ight), <strong>B</strong>(oth) change direction</li>
                                        <li><strong>Delete</strong> removes the transition</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <div id="eval-pane" class="tab-pane">
                        <div class="eval-input">
                            Enter a formula:
                            <input type="text" placeholder="e.g., (p -> []p)">
                            <button class="btn btn-block" onclick="app.evaluateFormula()">Evaluate</button>
                        </div>
                        <div class="eval-output inactive">
                        </div>
                        <div class="instructions">
                            <ul class="unstyled">
                                <li>
                                    When entering a formula:
                                    <ul>
                                        <li>use <code>~A</code> for $\lnot{}A$</li>
                                        <li>use <code>[]A</code> for $\Box{}A$</li>
                                        <li>use <code>&lt;&gt;A</code> for $\Diamond{}A$</li>
                                        <li>use <code>(A &amp; B)</code> for $(A\land{}B)$</li>
                                        <li>use <code>(A | B)</code> for $(A\lor{}B)$</li>
                                        <li>use <code>(A -&gt; B)</code> for $(A\rightarrow{}B)$</li>
                                        <li>use <code>(A &lt;-&gt; B)</code> for $(A\leftrightarrow{}B)$</li>
                                    </ul>
                                </li>
                                <li><strong>NB:</strong> Input is parenthesis-sensitive!
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="graph"></div>
                <div class="current-formula inactive"></div>
            </div>
        </section>
        <section class="row" id="report">
            <h2>
                Introduction
            </h2>
            <div class="alert alert-info" role="alert">
                Some introduction
            </div>
            <h3>
                Logic systems
            </h3>
            <div class="alert alert-info" role="alert">
                Some introduction
            </div>
            <h4>
                The axiom system $K_{(m)}$
            </h4>
            <div class="alert alert-info" role="alert">
                Introduction into $K_{(m)}$ possibly with truth definitions.
            </div>
            <h4>
                The axiom system $S5_{(m)}$
            </h4>
            <div class="alert alert-info" role="alert">
                Introduction into $S5_{(m)}$ possibly with truth definitions.
            </div>
            <h4>
                The axiom system $S5EC_{(m)}$
            </h4>
            <div class="alert alert-info" role="alert">
                Introduction into $S5EC_{(m)}$ possibly with truth definitions.
            </div>
            <h2>
                Implementation
            </h2> In this section we discuss how we represent the models and formulas within the model checker. Furthermore we also explain how the model checker verifies if a formula is true or not using these representations.
            <h3>
                Formula
            </h3> Since the axiom system $S5EC_{(m)}$ is a superset of $S5_{(m)}$, and $S5_{(m)}$ is a super set of $K_{(m)}$ we only discuss the representation of formulas in the axiom system $S5EC_{(m)}$.
            <br> Formulas are entered using the representation presented in the table below.
            <table class="table table-striped table-hover table-condensed">
                <tr>
                    <th></th>
                    <th>
                        Conventional notation
                    </th>
                    <th>
                        Input format
                    </th>
                    <th>
                        Notes
                    </th>
                </tr>
                <tr>
                    <td>
                        Proposition
                    </td>
                    <td>
                        $A$
                    </td>
                    <td>
                        <code>a</code>
                    </td>
                    <td>
                        The name of a proposition must start with a small letter.
                    </td>
                </tr>
                <tr>
                    <td>
                        Negation
                    </td>
                    <td>
                        $\lnot A$
                    </td>
                    <td>
                        <code>~a</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Conjunction
                    </td>
                    <td>
                        $A \land B$
                    </td>
                    <td>
                        <code>a &amp; b</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Conjunction
                    </td>
                    <td>
                        $A \land B$
                    </td>
                    <td>
                        <code>a &amp; b</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Disjunction
                    </td>
                    <td>
                        $A \lor B$
                    </td>
                    <td>
                        <code>a | b</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Implication
                    </td>
                    <td>
                        $A \to B$
                    </td>
                    <td>
                        <code>a -&gt; b</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Implication
                    </td>
                    <td>
                        $A \leftrightarrow B$
                    </td>
                    <td>
                        <code>a &lt;-&gt; b</code>
                    </td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        Knowledge
                    </td>
                    <td>
                        $K_i$
                    </td>
                    <td>
                        <code>K_i</code>
                    </td>
                    <td>
                        The name of the agent must be a number.
                    </td>
                </tr>
                <tr>
                    <td>
                        Possible
                    </td>
                    <td>
                        $M_i$
                    </td>
                    <td>
                        <code>M_i</code>
                    </td>
                    <td>
                        The name of the agent must be a number.
                    </td>
                </tr>
                <tr>
                    <td>
                        Common knowledge
                    </td>
                    <td>
                        $C$
                    </td>
                    <td>
                        <code>C</code>
                    </td>
                    <td></td>
                </tr>
            </table>
            To represent that it is common knowledge that agent $1$ knows that it is not the case that both $a$ and $b$ hold, i.e. \begin{equation} C K_1 \lnot (a \land b) \label{eq:exampleFormula} \end{equation} one would use
            <code>C K_1 ~(a &amp; b)</code> .
            <h4>
                Tokens
            </h4> Formulas that enter the model checker are converted to a list of tokens. The tokenized version of \eqref{eq:exampleFormula} is shown in the figure.
            <figure>
                <object data="./img/tokenization.svg" type="image/svg+xml" align="middle">
                    <img src="./img/tokenization.png" />
                </object>
                <figcaption>
                    Tokenization of formula \eqref{eq:exampleFormula}
                </figcaption>
            </figure>
            The advantage of tokenizing is that it is easier to change the definition of the non terminals of the grammar without having to change the parser it self. Another upside of representing the formula as a list of tokens before parsing it is that we can already detect some errors in the formulas. For example if a user has selected the axiom system $S5_{(m)}$ and inputs formula \eqref{eq:exampleFormula} the process that generates the list of tokens detects that the formula is not valid in that language. Since the operator $C$ is not defined in $S5_{(m)}$.
            <figure class="float-right">
                <object data="./img/ast.svg" type="image/svg+xml">
                    <img src="./img/ast.png" />
                </object>
                <figcaption>
                    Expression tree of formula \eqref{eq:exampleFormula}
                </figcaption>
            </figure>
            <h4>
                Expression Tree
            </h4> If we have the list op token we need to build the expression tree. We do that using this grammar: \begin{array}{cccl} E & := & ~ & \langle T \rangle \land \langle T \rangle \; | \; \langle T \rangle \lor \langle T \rangle \; | \; \langle T \rangle \to \langle T \rangle \; | \; \langle T \rangle \leftrightarrow \langle T \rangle\\ T & := & ~ & C \langle F \rangle \; | \; K_i \langle F \rangle \; | \; M_i \langle F \rangle\\ F & := & ~ & \left( \langle E \rangle \right) \; | \; ~ \lnot \langle E \rangle \; | \; \mathit{proposition}\\ \end{array} In this grammar, non-terminals are presented in pointy brackets, terminals are represented as their logic symbol or in recursive text. Based on this grammar we can parse the tokenized expression using a recursive descent parser. This results in an expression tree.
            <br> The structure of the tree represents the order in which parts of the formula should be evaluated. For example, $a \land b$ should be evaluated first, and the result of that expression should be negated. If we had not placed brackets around the conjunction the negation node would have been a child of the conjunction node.
            <br> All binary operators in the grammar are right-associative, i.e. the expression $a \land b \land c$ is parsed as $(a \land (b \land c))$.
            <h3>
                Model
            </h3>
            <div class="alert alert-info" role="alert">
                Something on how the model is represented as an adjacency list. Possibly an example of how a specific model is represented as json.
            </div>
            <h3>
                Checker
            </h3>
                <p>Given the expression tree and the model we can evaluate the expression. We simply start from the root node and follow its truth definition. For each node we generate a condition that needs to be full filled for the node to hold and a conclusion. For all nodes other than the proposition we also generate an 'interlude' which shows why the condition is full filled, or not. For example the formula $SOME FORMULA!$ would result in the following motivation in some model:
                    <blockquote>
                        <div class="alert alert-info" role="alert">
                            Some example
                        </div>
                    </blockquote>
                </p>
            <div class="alert alert-info" role="alert">
                Something on how we create the motivation for this evaluation, which is not yet
            </div>
            <h2>
            Visualisation
        </h2> The visualisation depicts a Kripke model as a graph. The worlds have a label that shows the valuations of the atomic propositions at that world. Reflexive relations are not supported at this moment.
            <h3>
            How to use
        </h3> At this stage the user interface is not quite finished yet and a (probably) temporal solution is in place. This temporal solution includes an json editor in which the model can be edited. Our goal is to include a more user friendly interface where states and links can be added by simply clicking in the in the graph canvas.
            <h4>
            JSON Format
        </h4> An example is included in the editor for this. It contains an object called model. Within this model the states, relations, and logic system are defined.
            <ul>
                <li> <strong>States</strong> is an array of objects. Each object represents a state and needs to have an "id" field followed by an integer. This id is used later in the relations. The "vals" field is followed by an array of valuations. The order of these valuations needs to be the same as that of the propositions array
                </li>
                <li> <strong>Relations</strong> This object needs to be an array of arrays. The inner arrays describe a relation between two states and of which of the maximum 5 agents this relations belongs to.
                </li>
                <li>
                    <strong>
                    Logic System
                </strong> The logic system the Kripke belongs to. Will in final version compute the reflexive transitive etc. closures when that is necessary. Options for the logic system are "KM", "S5", and "S5CE"
                </li>
            </ul>
            The model object is followed by the formula you want to check on the system. Syntax is described in the table at the top of the page. The state field tells the model checker in which state the formula should hold.
        </section>
        <footer>
            Epistemic Logic Playground is an adaption of
            <a href="https://github.com/rkirsling/modallogic">
            Modal Logic Playground
        </a> by
            <a href="https://bitbucket.org/rick_van_veen">
            Rick van Veen
        </a> and
            <a href="https://github.com/lauraBaakman">
            Laura Baakman
        </a> , released under the
            <a href="http://opensource.org/licenses/mit-license.php">
            MIT License
        </a> .
        </footer>
</body>

</html>
